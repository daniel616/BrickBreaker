package controls;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.ResourceBundle;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.AbstractMap.SimpleEntry;
import java.util.Map.Entry;
import java.util.regex.Pattern;

//import application.Turtle;

public class Parser {
	
	private static final String WHITESPACE = "\\s+";
	private static final String SYNTAX_LOCATION = "resources/languages/Syntax";
	private Controller control;
	//private Turtle turtle;
	private Queue<String> code;
	private List<Entry<String, Pattern>> commands;
	private List<Entry<String, Pattern>> syntax;
	
	public Parser(Controller c, String language) {
		control = c;
		setLanguage(language);
		addSyntax();
	}
	
	public Parser(Controller c, String language, Queue<String> info) {
		this(c, language);
		code = info;
	}

	public double addCode(String info) throws CommandNotFoundException, ReflectionException {
		info.split(WHITESPACE);
		code.addAll(new ArrayList<String>(Arrays.asList(info)));
		return parse();
	}
	
	private double parse() throws CommandNotFoundException, ReflectionException{
		if(!code.isEmpty()){
			String comName = code.poll();
			int amount = getAmountParameters(comName);

			List<String> parameters = new LinkedList<>();
			while(parameters.size()!=amount){
				try{
					getAmountParameters(code.peek());
					parameters.add(parse() + "");
				} catch(CommandNotFoundException | ReflectionException e){
					parameters.add(code.poll());
				}
			}
			// TODO Create and execute with comName and parameters using Reflection
			try {
				Class<?> clazz = Class.forName("commands/" + getCommandClass(comName));
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return 0;
	}

	private int getAmountParameters(String name) throws CommandNotFoundException, ReflectionException{
		try{
			Class<?> clazz = Class.forName("commands/" + getCommandClass(name));
			// TODO methodName
			Method m = clazz.getMethod("methodName", Integer.class);
			return (int)m.invoke(null, null);
		} catch(ClassNotFoundException e) {
			throw new CommandNotFoundException(name);
			/*try{
				// TODO
				// Ask Kyle to run a user implemented command...
				return 0;
			} catch(CommandNotFoundException ex){
				throw ex;
			}*/
		} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			throw new ReflectionException();
		}
	}
	
	private void addSyntax() {
		commands = new ArrayList<>();
		ResourceBundle options = ResourceBundle.getBundle(SYNTAX_LOCATION);
        Enumeration<String> iter = options.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            String regex = options.getString(key);
            syntax.add(new SimpleEntry<>(key, Pattern.compile(regex, Pattern.CASE_INSENSITIVE)));
        }
	}

	public void setLanguage(String language) {
		commands = new ArrayList<>();
		// TODO throw languagenotfoundexception
		ResourceBundle options = ResourceBundle.getBundle(language);
        Enumeration<String> iter = options.getKeys();
        while (iter.hasMoreElements()) {
            String key = iter.nextElement();
            String regex = options.getString(key);
            commands.add(new SimpleEntry<>(key, Pattern.compile(regex, Pattern.CASE_INSENSITIVE)));
        }
	}


    private String getCommandClass(String name) throws ClassNotFoundException {
        for(Entry<String, Pattern> c: commands)
            if (match(name, c.getValue()))
                return c.getKey();
        throw new ClassNotFoundException(name);
    }

    private boolean match (String text, Pattern regex) {
        return regex.matcher(text).matches();
    }
}