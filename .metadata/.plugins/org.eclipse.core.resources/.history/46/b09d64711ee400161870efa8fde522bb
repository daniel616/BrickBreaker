package application;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Random;
import java.util.Scanner;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.Stage;
import javafx.util.Duration;


/**
 *Code taken and edited from Professor Duvall's lab
 *This class contains the code used to generate
 * @author Daniel Li
 */
public class GameWorld extends Application {
	/*
	 * Populates each scene and keeps track of the paddle, bricks, powerups and bouncers within the game.
	 * Also handles animation and player interactions.
	 * Tracks score and lives.
	 * Grants bouncers powerups when the powerup hits the paddle.
	 */
	
    public static final String TITLE = "Breakout!";
    private static final String BALL_IMAGE = "ball.gif";
    public static final int SIZE = 600;
    public static final Paint BACKGROUND = Color.WHITE;
    public static final int FRAMES_PER_SECOND = 600;
    public static final int MILLISECOND_DELAY = 1000 / FRAMES_PER_SECOND;
    public static final double SECOND_DELAY = 1.0 / FRAMES_PER_SECOND;
    public static final int KEY_INPUT_SPEED = 5;
    public static final double PADDLEWIDTH=0.15;
    public static final double PADDLEHEIGHT=0.025;
    public static final double PADDLE_ELEVATION=0.9;
    public static final double PADDLECONTROL=150;
    private double POWER_FALL_SPEED=50;
    private double ACCELERATION=1.25;
    private double DECCELERATION=0.64;
    private final int DEFAULTLIVES=4;
    private final double bouncerYVelocity=-200;
    private final double bouncerXVelocity=20;
    private static boolean playing=true;
    private static final Label pauseMessage=new Label("Press space to continue");
    private static final Button returnMessage=new Button("Return to menu");
    
    
    // some things we need to remember during our game
    private int lives=DEFAULTLIVES;
    private int screen=0;
    private int score=0;
    private ImageView paddle;
    private Label lifeLabel;
    private Label screenLabel;
    private Label scoreLabel;
    private ArrayList<PowerUp> powerUpList=new ArrayList<PowerUp>();
    private ArrayList<Bouncer> bouncerList=new ArrayList<Bouncer>();
    private ArrayList<Brick> brickList=new ArrayList<Brick>();
    Timeline animation = new Timeline();
    private Scene myScene;
    private Group root=new Group();

    
    /**
     * Initialize what will be displayed and how it will be updated.
     * @throws FileNotFoundException 
     */
    @Override
    public void start (Stage s) throws FileNotFoundException {
        // attach scene to the stage and display it
    	myScene = new Scene(root,SIZE,SIZE,BACKGROUND);
    	s.setScene(myScene);
        s.setTitle(TITLE);
        s.show();
       
        //sets up return button for future use
        makeReturnButton();
        
        // attach "game loop" to timeline to play it
        KeyFrame frame = new KeyFrame(Duration.millis(MILLISECOND_DELAY), e -> {
										try {
											step(SECOND_DELAY);
										} catch (FileNotFoundException e1) {
											// TODO Auto-generated catch block
											e1.printStackTrace();
										}
									}); //do something every few milliseconds
        animation.setCycleCount(Timeline.INDEFINITE);
        animation.getKeyFrames().add(frame);
        animation.play();
        myScene.setOnKeyPressed(e->{
			try {
				handleKeyInput(e.getCode());
			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		});
    	setUpScreens();
    }
    
    //Sets up label messages and label positions.
    private void setUpLabels(){
    	lifeLabel=new Label("Lives: "+lives);
    	screenLabel= new Label("Screen: "+screen);
    	scoreLabel=new Label("Score: "+lives);
    	root.getChildren().addAll(lifeLabel,screenLabel,scoreLabel);
    	lifeLabel.setLayoutX(SIZE-75);
    	screenLabel.setLayoutX(SIZE-75);
    	scoreLabel.setLayoutX(SIZE-75);
    	lifeLabel.setLayoutY(5);
    	scoreLabel.setLayoutY(20);
    	screenLabel.setLayoutY(35);
    }
    
    private void updateLabels(){
    	lifeLabel.setText("Lives: "+lives);
    	screenLabel.setText("Screen: "+screen);
    	scoreLabel.setText("Score: "+score);
    }

    //Creates a button that returns to the start screen.
	private void makeReturnButton() {
		returnMessage.setOnAction(new EventHandler<ActionEvent>(){
			@Override
			public void handle(ActionEvent event){
				screen=0;
				try {
					setUpScreens();
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
		});
	}
    
	//Clears the root and populates it with the contents of whichever screen we should be on.
    private void setUpScreens() throws FileNotFoundException{
    	root.getChildren().clear();
    	brickList.clear();
    	bouncerList.clear();
    	setUpLabels();
    	if(lives==0&&screen<=3&&screen>=1) screen=5;
    	if(screen<=3&&screen>=1)makeGameMap();
    	if(screen==6){
    		Label powerDescriptor=new Label("Red powerup: adds a ball to the game and multiplies point gain rate, "
    				+ "but losing any ball causes loss of life."
    				+ "Yellow powerup: decrease ball speed, +5pts. Green powerup: increase ball speed, +10 pts.");
    		root.getChildren().add(powerDescriptor);
    		powerDescriptor.setMaxWidth(300); 
    		powerDescriptor.setWrapText(true);
    		root.applyCss();
    		root.layout();
    		powerDescriptor.setLayoutX(SIZE/2-powerDescriptor.getWidth()/2);
    		
    		
    		String s="Use mouse to control paddle. Hit the ball with the center of the paddle"
    				+ " to adjust velocity upwards, and on the side of the paddle to adjust velocity sideways."
    				+ "Press 1, 2, or 3 to switch level. Press 'l' to remove fear of death.";
    		messageScreen(s);
    		
    	}
    	if(screen==5){
    		messageScreen("You lost!");
    	}
    	if(screen==0)makeStartingScreen();
    
    	if(screen==4){
    		messageScreen("You won!");	
    	}
    }
    
    //Displays a string at the center of the map, and adds a return button below
	private void messageScreen(String message) {
		Label shownMessage=new Label(message);
		root.getChildren().add(shownMessage);
		shownMessage.setWrapText(true);
		shownMessage.setMaxWidth(300);
		root.getChildren().add(returnMessage);
		root.applyCss();
		root.layout();
		shownMessage.setLayoutX(SIZE/2-shownMessage.getWidth()/2);
		shownMessage.setLayoutY(SIZE/4);
		returnMessage.setLayoutX(SIZE/2-returnMessage.getWidth()/2);
		returnMessage.setLayoutY(SIZE/2);
	}

	//creates the buttons that are present in the starting screen
	private void makeStartingScreen() {
		lives=DEFAULTLIVES;
		score=0;
		Label title= new Label("Breakout");
		title.setScaleX(2);
		title.setScaleY(2);
		Button startButton=new Button("Click to start");   		
		setMapping(startButton,1);
		Button tipButton=new Button("Tips");
		setMapping(tipButton,6);
		
		root.getChildren().add(tipButton);
		root.getChildren().add(title);
		root.getChildren().add(startButton);
		root.applyCss();
		root.layout();
		title.setLayoutX(SIZE/2-title.getWidth()/2);
		title.setLayoutY(SIZE/2);
		startButton.setLayoutX(SIZE/2-startButton.getWidth()/2);
		startButton.setLayoutY(SIZE/2+0.1*SIZE);
		tipButton.setLayoutX(SIZE/2-tipButton.getWidth()/2);
		tipButton.setLayoutY(SIZE/2+0.2*SIZE);
		
	}
	
	//Creates buttons that take the player to the nth screen
	private void setMapping(Button button, int n) {
		button.setOnAction(new EventHandler<ActionEvent>(){
			@Override
			public void handle(ActionEvent event){
				screen=n;
				try {
					setUpScreens();
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				handlePauses();
			}
			
		});
	}
	
	//Uses a scanner to make the levels which the player can play on, NOT the text screens
    private void makeGameMap(){
    	File f=new File("maps/"+screen+".txt");
       	Scanner sc;
		try {
			sc = new Scanner(f);
			while(sc.hasNext()){
	       		sc.useLocale(Locale.US);
	        	double x=sc.nextDouble();
	        	double y=sc.nextDouble();
	       		int health=(int)sc.nextDouble();       		
	       		ImageView brick=makeSprite("brick"+health+".gif",x,y);
	       		brick.setFitHeight(0.05*SIZE);
	       		brick.setFitWidth(0.1*SIZE);
	       		brickList.add(new Brick(health,brick));
	       	}
	       	sc.close();
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
		}
		Bouncer b=new Bouncer(makeSprite(BALL_IMAGE,0.5,0.8), bouncerXVelocity,bouncerYVelocity,SIZE);
    	bouncerList.add(b);  	
    	paddle=makeSprite("paddle.gif",0.5,PADDLE_ELEVATION);
    	paddle.setFitWidth(PADDLEWIDTH*SIZE);
    	paddle.setFitHeight(PADDLEHEIGHT*SIZE);
        handlePauses();
        
        myScene.setOnMouseMoved(e->trackMouseMovement(e.getX()));
    }

    
    //Slightly adjusts everything in the Scene; is similar to changing a frame in an animation
    private void step(double elapsedTime) throws FileNotFoundException {
    	for(Bouncer bouncer:bouncerList){
    		ImageView sprite=bouncer.getSprite();
    		sprite.setX(sprite.getX()+bouncer.xVelocity()*elapsedTime);
    		sprite.setY(sprite.getY()+bouncer.yVelocity()*elapsedTime);
    	}
    	
    	bouncerInteractions();
    	
    	ArrayList<PowerUp> tempList=new ArrayList<>();
    	for(PowerUp p:powerUpList){
    		ImageView sprite=p.getSprite();
    		sprite.setY(sprite.getY()+POWER_FALL_SPEED*elapsedTime);
    		if(!pickedUp(p)){
    			tempList.add(p);
    		}else{
    			gainPower(p.getVersion());
    			root.getChildren().remove(p.getSprite());
    		}
    	}
    	powerUpList=tempList;
    	
    	if(brickList.size()==0&&screen<=3&&screen>=1){
    		screen++;   
			setUpScreens();
			
    	}
    	updateLabels();
    }
    
    //Tells the bouncer to bounce. If the bouncer goes out of bounds, restarts map and reduces lives.
    private void bouncerInteractions() throws FileNotFoundException{
    	boolean death=false;
    	for(Bouncer bouncer: bouncerList){
    		brickCollision(bouncer);
    		paddleInfluence(bouncer);
    		bouncer.wallBounce();
    		if(checkDeath(bouncer)){
    			death=true;
    		}
    	}
    	if(death==true){
    		lives--;
    		score-=3;
    		setUpScreens();
    	}
    }
	
    //Checks if bouncer is out of bounds
	private boolean checkDeath(Bouncer bouncer){
		ImageView sprite=bouncer.getSprite();
		return(sprite.getY()+sprite.getFitHeight()>SIZE);		
	}
	
	//Calls collisionPhysics to bounce bouncer off bricks.
	//Decrements brick health or destroys bricks on collision.
	private void brickCollision(Bouncer bouncer) {
		ArrayList<Brick> newBricks=new ArrayList<>();
		for(Brick brick: brickList){
			if(bounceOff(bouncer,brick.getSprite())){
				brick.healthDecrement();
				score+=1;
				if(brick.getHealth()>0){
					newBricks.add(brick);
				}
				else{
					root.getChildren().remove(brick.getSprite());
					randomDrop(brick);
				}
			}
			else{
				newBricks.add(brick);
			}
		}
		if(brickList.size()!=newBricks.size()){
			brickList=newBricks;
			System.gc();
		}
	}
	
	//Randomly drops powerups.
	private void randomDrop(Brick brick){
		Random rn=new Random();
		int x=rn.nextInt(18);
		double brickX=brick.getSprite().getX();
		double brickY=brick.getSprite().getY();
		if(x<=5){
			dropPower(1,brickX,brickY);
		}
		else if(x<=7){
			dropPower(2,brickX,brickY);
		}
		else if(x<=10){
			dropPower(3,brickX,brickY);
		}
	}
	
	//Initializes a specific powerup at a specific location.
	private void dropPower(int n, double x, double y){
		ImageView sprite=makeSprite(n+".gif",x/SIZE,y/SIZE);
		PowerUp p=new PowerUp(n,sprite);
		powerUpList.add(p);
	}
    
	//Adds a vector to the motion of the bouncer depending on where it landed.
	//Magnitude of velocity is set back to initial magnitude afterwards, so speed stays same.
	private void paddleInfluence(Bouncer bouncer) {
		if(bounceOff(bouncer,paddle)){
			double dx=bouncer.getSprite().getX()+bouncer.getSprite().getFitWidth()/2-paddle.getX();
			double angle=Math.PI*dx/paddle.getFitWidth();
			double xVel=bouncer.xVelocity()-Math.cos(angle)*PADDLECONTROL;
			double yVel=bouncer.yVelocity()-Math.sin(angle)*PADDLECONTROL;
			double speedRatio=Math.sqrt((bouncer.xVelocity()*bouncer.xVelocity()+bouncer.yVelocity()*bouncer.yVelocity())/
					(xVel*xVel+yVel*yVel));
			bouncer.setVelocity(xVel*speedRatio,yVel*speedRatio);   			
		}
	}
    
	//Checks to see if bouncer intersects with sprite, and bounces if it is in contact.
    private boolean bounceOff(Bouncer bouncer, ImageView sprite){
    	//this kind of collision only works if things don't move by a lot per frame.
    	double bouncerWidth=bouncer.getSprite().getFitWidth();
		double bouncerHeight=bouncer.getSprite().getFitHeight();
		double bouncerX=bouncer.getSprite().getX()+bouncerWidth/2;
		double bouncerY=bouncer.getSprite().getY()+bouncerHeight/2;
		
		double spriteWidth=sprite.getFitWidth();
		double spriteHeight=sprite.getFitHeight();
		double spriteX=sprite.getX()+spriteWidth/2;
		double spriteY=sprite.getY()+spriteHeight/2;
		
		if(Math.abs(bouncerX-spriteX)<(spriteWidth+bouncerWidth)/2
				&&Math.abs(bouncerY-spriteY)<(spriteHeight+bouncerHeight)/2){
			if((bouncerHeight+spriteHeight)/2-Math.abs(bouncerY-spriteY)<
					(bouncerWidth+spriteWidth)/2-Math.abs(bouncerX-spriteX)){
				bouncer.reverseY();	
			}
			else{
				bouncer.reverseX();
			}			
			return true;
		}
		return false;
    	   	
    }
    
    //
    private boolean pickedUp(PowerUp p){
    	ImageView powerSprite=p.getSprite();
    	double powerUpWidth=powerSprite.getFitWidth();
		double powerUpHeight=powerSprite.getFitHeight();
		double powerUpX=powerSprite.getX()+powerUpWidth/2;
		double powerUpY=powerSprite.getY()+powerUpHeight/2;
		
		double paddleWidth=paddle.getFitWidth();
		double paddleHeight=paddle.getFitHeight();
		double paddleX=paddle.getX()+paddleWidth/2;
		double paddleY=paddle.getY()+paddleHeight/2;
		
		return(Math.abs(powerUpX-paddleX)<(paddleWidth+powerUpWidth)/2
				&&Math.abs(powerUpY-paddleY)<(paddleHeight+powerUpHeight)/2);
    }
    
    //Applies speed adjustments to bouncers or adds bouncers to scenario.
    private void gainPower(int n){
    	if(n==1){
    		for(Bouncer b:bouncerList){
    			b.setVelocity(b.xVelocity()*ACCELERATION, b.yVelocity()*ACCELERATION);
    			score+=10;
    		}
    	}
    	if(n==2){
    		for(Bouncer b:bouncerList){
    			b.setVelocity(b.xVelocity()*DECCELERATION, b.yVelocity()*DECCELERATION);
    			score+=5;
    		}
    	}
    	if(n==3){
    		ImageView ball=makeSprite(BALL_IMAGE, 0.5,0.5);
    		Bouncer b=new Bouncer(ball, bouncerXVelocity,bouncerYVelocity,SIZE);
    		bouncerList.add(b);
    	}
    }
    
    
    //Helper method that creates an ImageView and attaches it to the root node.
    private ImageView makeSprite(String imageName, double x, double y){
    	Image image=new Image(getClass().getClassLoader().getResourceAsStream(imageName));
    	ImageView sprite=new ImageView(image);
    	sprite.setX(x*SIZE);
    	sprite.setY(y*SIZE);
    	root.getChildren().add(sprite);
    	return sprite;
    }

    //Switches screens depending on input, and allows player to become invincible if 'l' is pressed.
    private void handleKeyInput (KeyCode code) throws FileNotFoundException {
        if (code== KeyCode.SPACE) handlePauses();
       
        if (code==KeyCode.DIGIT0){
        	screen=0;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT1){
        	screen=1;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT2){
        	screen=2;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT3){
        	screen=3;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT4){
        	screen=4;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT5){
        	screen=5;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT6){
        	screen=6;
        	setUpScreens();
        }
        if (code==KeyCode.L){
        	lives=-100;
        	score=-9999;
        }
    }
    
    //Toggles between pausing the scenario and adding a pause message and returning to original state.
    private void handlePauses(){
    	if(playing==true){
    		animation.stop();
    		root.getChildren().add(pauseMessage);
    		root.applyCss();
    		root.layout();
    		pauseMessage.setLayoutX(SIZE/2-pauseMessage.getWidth()/2);
    		pauseMessage.setLayoutY(SIZE/2);
    		
    		playing=false;
    	}
    	else{
    		animation.play();
    		root.getChildren().remove(pauseMessage);
    		playing=true;
    	}
    }
    
    private void trackMouseMovement(double x){
    	paddle.setX(x);
    }

    public static void main (String[] args) {
        launch(args);
    }
}
