package controls;

import java.util.HashSet;
import java.util.Set;

import javafx.collections.*;
import TurtleDetails.TurtleState;
import TurtleDetails.TurtleTrail;
import application.Model;
import exceptions.StateNotFoundException;
import gui.UserInterface;
import javafx.beans.property.SimpleObjectProperty;


/**
 * This class will act as a controller that interfaces objects
 * and methods in the view of our program with the objects and
 * methods in the model of our program.
 * 
 * Created February 23rd, 2017
 * @author Jake Conroy
 *
 */

public class Controller {
	private Model model;
	private Parser parser;
	private String currCommands;
	private String currConsoleMessage;
	private SimpleObjectProperty<ObservableList<String>> prevCommands = new SimpleObjectProperty<>(FXCollections.observableArrayList());
	private UserInterface myUI;
	
	public Controller() {
		model=new Model();
		myUI=new UserInterface(this);
		bind(myUI,model);
		parser=new Parser(this);
	}
	
	public Set<TurtleState> getTurtleStates(){
		Set<TurtleState> turtleStates=new HashSet<>();
		try{
			turtleStates=model.getTurtleStates();
			
			return turtleStates;
		}
		catch(StateNotFoundException e){
			displayException(e);
			return null;
		}
	}
	
	public Set<TurtleTrail> getTurtleTrails(){
		Set<TurtleTrail> myTrails=model.readOnlyTrails();
		return myTrails;
	}
	
	public void updateTrails(){
		try {
			model.updateTrails();
		} catch (StateNotFoundException e) {
			// TODO Auto-generated catch block
			displayException(e);
		}
	}
	
	public void updateTurtles(){
		try {
			model.updateTurtles();
		} catch (StateNotFoundException e) {
			// TODO Auto-generated catch block
			displayException(e);
		}
	}
	
	private void displayException(Exception e){
		e.printStackTrace();//remove later
		myUI.getOutputBox().setText(e.getMessage());
	}
	
	public UserInterface getInterface(){
		return myUI;
	}
	
	public void parseInput(String command) {
		try {
			parser.addCode(command);
		} catch (Exception e){
			displayException(e);
		}
	}
	
	public void handleCommand(String command) {
		//Parser.takeCommand(command);
	}
	
	/**
	 * USE: From View to Controller
	 * @param command is the string representation of the command from the front end
	 */
	public void setCurrCommands(String command) {
		currCommands = command;
	}
	/**
	 * USE: From Controller to Model
	 * @return command is the string representation of the command from the front end
	 */
	public String getCurrCommands() {
		return currCommands;
	}	
	
	/**
	 * USE: From Model to Controller
	 * @param consoleMessage is a string representation that the parser will send
	 * to the front end if necessary
	 */
	public void setCurrConsoleMessage(String consoleMessage) {
		currConsoleMessage = consoleMessage;
	}
	/**
	 * USE: From Controller to View
	 * @return consoleMessage is a string representation that the parser will send
	 * to the front end if necessary
	 */
	public String getCurrConsoleMessage() {
		return currConsoleMessage;
	}
	
	
	public void addCommandToDropDown(String command) {
		prevCommands.getValue().add(command);
	}
	
	public SimpleObjectProperty<ObservableList<String>> getPreviousCommands() {
		return prevCommands;
	}
	
	public Model getModel(){
		return model;
	}
	
	private void bind(UserInterface u, Model model){
		ObservableList<String> history=FXCollections.observableList(model.readOnlyHistory());
		ObservableMap<String, String> commands=FXCollections.observableMap(model.readOnlyCommands());
		ObservableMap<String, String> variables=FXCollections.observableMap(model.readOnlyVariables());
		//u.getHistoryBox().setListener(history);
		//u.getVariableBox().setListener(variables);
	}
}
