package controls;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import TurtleDetails.Turtle;

import TurtleDetails.TurtleSpriteDetails;
import TurtleDetails.TurtleState;
import TurtleDetails.TurtleTrail;
import application.Model;
import exceptions.StateNotFoundException;
import gui.UserInterface;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;


/**
 * This class will act as a controller that interfaces objects
 * and methods in the view of our program with the objects and
 * methods in the model of our program.
 * 
 * Created February 23rd, 2017
 * @author Jake Conroy
 *
 */

public class Controller {
	private Model model;
	private Parser parser;
	private String currCommands;
	private String currConsoleMessage;
	private SimpleObjectProperty<ObservableList<String>> prevCommands = new SimpleObjectProperty<>(FXCollections.observableArrayList());
	private UserInterface myUI;
	
	public Controller() {
		ObservableMap<String,Turtle>myTurtles=FXCollections.observableMap(new HashMap<String,Turtle>());
		myTurtles.put("turtle", new Turtle());
		ObservableSet<TurtleTrail>allTrails=FXCollections.observableSet(new HashSet<>());
		ObservableList<String>inputHistory=FXCollections.observableList(new ArrayList<>());
		ObservableMap<String,String>userCommands=FXCollections.observableMap(new HashMap<>());
		ObservableMap<String,String>userVariables=FXCollections.observableMap(new HashMap<>());
		model=new Model(allTrails,inputHistory,userCommands,userVariables);
		myUI=new UserInterface(this);
		//parser=new Parser(this,"resources.languages/English");
	}	
	
	public Collection<TurtleState> getTurtleStates(){
		Map<String,Turtle> turtles=model.getTurtlesCopy();
		ArrayList<TurtleState> turtleStates=new ArrayList<>();
		try{
			for(Turtle t:turtles.values()){
				turtleStates.add(t.getFirstTurtleState());
			}
			
			return turtleStates;
		}
		catch(StateNotFoundException e){
			displayException(e);
			return null;
		}
	}
	
	public Collection<TurtleTrail> getTurtleTrails(){
		Collection<TurtleTrail> myTrails=model.getTrails();
		return myTrails;
	}
	
	public void displayException(Exception e){
		//print to console
	}
	
	public Model getModel(){
		return model;
	}
	
	public UserInterface getInterface(){
		return myUI;
	}
	
	public void parseInput(String command) {
		System.out.println(command);
	}
	
	public void handleCommand(String command) {
		//Parser.takeCommand(command);
	}
	
	/**
	 * USE: From View to Controller
	 * @param command is the string representation of the command from the front end
	 */
	public void setCurrCommands(String command) {
		currCommands = command;
	}
	/**
	 * USE: From Controller to Model
	 * @return command is the string representation of the command from the front end
	 */
	public String getCurrCommands() {
		return currCommands;
	}	
	
	/**
	 * USE: From Model to Controller
	 * @param consoleMessage is a string representation that the parser will send
	 * to the front end if necessary
	 */
	public void setCurrConsoleMessage(String consoleMessage) {
		currConsoleMessage = consoleMessage;
	}
	/**
	 * USE: From Controller to View
	 * @return consoleMessage is a string representation that the parser will send
	 * to the front end if necessary
	 */
	public String getCurrConsoleMessage() {
		return currConsoleMessage;
	}
	
	
	public void addCommandToDropDown(String command) {
		prevCommands.getValue().add(command);
	}
	
	public SimpleObjectProperty<ObservableList<String>> getPreviousCommands() {
		return prevCommands;
	}
}
