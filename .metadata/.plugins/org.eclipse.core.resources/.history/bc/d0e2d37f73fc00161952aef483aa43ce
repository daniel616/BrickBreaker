package TurtleDetails;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

import exceptions.StateNotFoundException;
import javafx.scene.paint.Color;
import sun.misc.Queue;
/**
 * @author Daniel
 * Stores an arraylist of states that functions as a queue. Uses the first and second states in the list to
 * create turtleTrails, and adds new states to the back of the list. You can only add to the back, but you can
 * look at both the front and the back. You can only remove from the back.
 * Throws exceptions if states aren't found.
 */
public class Turtle{
	private List<TurtleState> myStates;
	private Collection<TurtleTrail> myTrails;

	public Turtle(double x, double y, double heading, boolean penDown, Color penColor, boolean turtleShowing){
		myStates=new ArrayList<TurtleState>();
		myTrails=new HashSet<>();
		addTurtleState(x,y,heading,penDown,penColor,turtleShowing);
	}
	
	public Turtle(){
		//Instantiates at origin atm
		this(0,0,0,true,Color.BLACK,true);
	}
	
	//Returns a turtleTrail based on the first and second elements in TurtleStates.
	public TurtleTrail makeNextTrail() throws StateNotFoundException{
		if(myStates.size()<2){
			throw new StateNotFoundException(myStates.size());
		}
		
		TurtleState state0=myStates.get(0);
		TurtleState state1=myStates.get(1);
		TurtleTrail trail=new TurtleTrail(state0.getX(),state0.getY(),state1.getX(),
				state1.getY(),state1.penDown(),state1.getColor());
		return trail;
	}
	
	public void removeFirstState() throws StateNotFoundException{
		if(myStates.isEmpty()){
			throw new StateNotFoundException(0);
		}
		myStates.remove(0);
	}
	
	//Adds a new element to the back of the list, corresponding to the latest change of state to be performed once the previous ones have been dealt with.
	//Makes the list look like a queue, because you can only add to the back.
	public void addTurtleState(double x, double y, double heading, boolean penDown, Color penColor, boolean turtleShowing) {
		myStates.add(new TurtleState(x,y,heading, penDown,penColor,turtleShowing));
	}
	
	public TurtleState getFinalTurtleState() throws StateNotFoundException {
		if(myStates.isEmpty()){
			throw new StateNotFoundException(0);
		}
		return myStates.get(myStates.size()-1);
	}
<<<<<<< HEAD
	
	public TurtleState getFirstTurtleState() throws StateNotFoundException {
=======

	//Returns variables corresponding to the Turtle�s �current state�. Throws exceptions if list is empty.
	public double getX() throws StateNotFoundException {
		return currentState().getX();
	}

	public double getY() throws StateNotFoundException {
		return currentState().getY();
	}

	public double getHeading() throws StateNotFoundException {
		return currentState().getHeading();
	}

	public boolean penDown() throws StateNotFoundException {
		return currentState().penDown();
	}

	public boolean isShowing() throws StateNotFoundException {
		return currentState().turtleShowing();
	}	

	private TurtleState currentState() throws StateNotFoundException{
>>>>>>> cdd0f0c1bfea40ad921178e939a0f0b4c6a221fe
		if(myStates.isEmpty()){
			throw new StateNotFoundException(0);
		}
		return myStates.get(0);
	}
	
	public Collection<TurtleTrail> getTrails(){
		return myTrails;
	}
}