package application;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Random;
import java.util.Scanner;

import application.Bouncer;
import application.Brick;
import application.PowerUp;
import application.WorldPopulator;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.Stage;
import javafx.util.Duration;


/**
 *Code taken and edited from Professor Duvall's lab
 *This class contains the code used to generate
 * @author Daniel Li
 */
public class GameWorld extends Application {
    public static final String TITLE = "Breakout!";
    private static final String BALL_IMAGE = "ball.gif";
    public static final int SIZE = 600;
    public static final Paint BACKGROUND = Color.WHITE;
    public static final int FRAMES_PER_SECOND = 600;
    public static final int MILLISECOND_DELAY = 1000 / FRAMES_PER_SECOND;
    public static final double SECOND_DELAY = 1.0 / FRAMES_PER_SECOND;
    public static final int KEY_INPUT_SPEED = 5;
    public static final double PADDLEWIDTH=0.15;
    public static final double PADDLEHEIGHT=0.025;
    public static final double PADDLE_ELEVATION=0.9;
    public static final double PADDLECONTROL=150;
    private static boolean playing=true;
    private static final Label pauseMessage=new Label("Press space to continue");
    private static final Button returnMessage=new Button("Return to menu");
    
    
    WorldPopulator data = new WorldPopulator(50, 1.25, 0.64, 4, -200, 20, 0, 0, new ArrayList<PowerUp>(), new ArrayList<Bouncer>(), new ArrayList<Brick>(),
			new Timeline(), new Group());


	/**
     * Initialize what will be displayed and how it will be updated.
     * @throws FileNotFoundException 
     */
    @Override
    public void start (Stage s) throws FileNotFoundException {
        // attach scene to the stage and display it
    	data.myScene = new Scene(data.root,SIZE,SIZE,BACKGROUND);
    	s.setScene(data.myScene);
        s.setTitle(TITLE);
        s.show();
       
        //sets up return button for future use
        makeReturnButton();
        
        // attach "game loop" to timeline to play it
        KeyFrame frame = new KeyFrame(Duration.millis(MILLISECOND_DELAY), e -> {
										try {
											step(SECOND_DELAY);
										} catch (FileNotFoundException e1) {
											// TODO Auto-generated catch block
											e1.printStackTrace();
										}
									}); //do something every few milliseconds
        data.animation.setCycleCount(Timeline.INDEFINITE);
        data.animation.getKeyFrames().add(frame);
        data.animation.play();
        data.myScene.setOnKeyPressed(e->{
			try {
				handleKeyInput(e.getCode());
			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		});
    	setUpScreens();
    }
    
    private void setUpLabels(){
    	data.lifeLabel=new Label("Lives: "+data.lives);
    	data.screenLabel= new Label("Screen: "+data.screen);
    	data.scoreLabel=new Label("Score: "+data.lives);
    	data.root.getChildren().addAll(data.lifeLabel,data.screenLabel,data.scoreLabel);
    	data.lifeLabel.setLayoutX(SIZE-75);
    	data.screenLabel.setLayoutX(SIZE-75);
    	data.scoreLabel.setLayoutX(SIZE-75);
    	data.lifeLabel.setLayoutY(5);
    	data.scoreLabel.setLayoutY(20);
    	data.screenLabel.setLayoutY(35);
    }
    
    private void updateLabels(){
    	data.lifeLabel.setText("Lives: "+data.lives);
    	data.screenLabel.setText("Screen: "+data.screen);
    	data.scoreLabel.setText("Score: "+data.score);
    }

	private void makeReturnButton() {
		returnMessage.setOnAction(new EventHandler<ActionEvent>(){
			@Override
			public void handle(ActionEvent event){
				data.screen=0;
				try {
					setUpScreens();
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
		});
	}
    
    private void setUpScreens() throws FileNotFoundException{
    	data.root.getChildren().clear();
    	data.brickList.clear();
    	data.bouncerList.clear();
    	setUpLabels();
    	if(data.lives==0&&data.screen<=3&&data.screen>=1) data.screen=5;
    	if(data.screen<=3&&data.screen>=1)makeGameMap();
    	if(data.screen==6){
    		Label powerDescriptor=new Label("Red powerup: adds a ball to the game and multiplies point gain rate, "
    				+ "but losing any ball causes loss of life."
    				+ "Yellow powerup: decrease ball speed, +5pts. Green powerup: increase ball speed, +10 pts.");
    		data.root.getChildren().add(powerDescriptor);
    		powerDescriptor.setMaxWidth(300); 
    		powerDescriptor.setWrapText(true);
    		data.root.applyCss();
    		data.root.layout();
    		powerDescriptor.setLayoutX(SIZE/2-powerDescriptor.getWidth()/2);
    		
    		
    		String s="Use mouse to control paddle. Hit the ball with the center of the paddle"
    				+ " to adjust velocity upwards, and on the side of the paddle to adjust velocity sideways."
    				+ "Press 1, 2, or 3 to switch level. Press 'l' to remove fear of death.";
    		messageScreen(s);
    		
    	}
    	if(data.screen==5){
    		messageScreen("You lost!");
    	}
    	if(data.screen==0)makeStartingScreen();
    
    	if(data.screen==4){
    		messageScreen("You won!");	
    	}
    }

	private void messageScreen(String message) {
		Label shownMessage=new Label(message);
		data.root.getChildren().add(shownMessage);
		shownMessage.setWrapText(true);
		shownMessage.setMaxWidth(300);
		data.root.getChildren().add(returnMessage);
		data.root.applyCss();
		data.root.layout();
		shownMessage.setLayoutX(SIZE/2-shownMessage.getWidth()/2);
		shownMessage.setLayoutY(SIZE/4);
		returnMessage.setLayoutX(SIZE/2-returnMessage.getWidth()/2);
		returnMessage.setLayoutY(SIZE/2);
	}

	private void makeStartingScreen() {
		data.lives=data.DEFAULTLIVES;
		data.score=0;
		Label title= new Label("Breakout");
		title.setScaleX(2);
		title.setScaleY(2);
		Button startButton=new Button("Click to start");   		
		setMapping(startButton,1);
		Button tipButton=new Button("Tips");
		setMapping(tipButton,6);
		
		data.root.getChildren().add(tipButton);
		data.root.getChildren().add(title);
		data.root.getChildren().add(startButton);
		data.root.applyCss();
		data.root.layout();
		title.setLayoutX(SIZE/2-title.getWidth()/2);
		title.setLayoutY(SIZE/2);
		startButton.setLayoutX(SIZE/2-startButton.getWidth()/2);
		startButton.setLayoutY(SIZE/2+0.1*SIZE);
		tipButton.setLayoutX(SIZE/2-tipButton.getWidth()/2);
		tipButton.setLayoutY(SIZE/2+0.2*SIZE);
		
	}

	private void setMapping(Button button, int n) {
		button.setOnAction(new EventHandler<ActionEvent>(){
			@Override
			public void handle(ActionEvent event){
				data.screen=n;
				try {
					setUpScreens();
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				handlePauses();
			}
			
		});
	}

    private void makeGameMap(){
    	File f=new File("maps/"+data.screen+".txt");
       	Scanner sc;
		try {
			sc = new Scanner(f);
			while(sc.hasNext()){
	       		sc.useLocale(Locale.US);
	        	double x=sc.nextDouble();
	        	double y=sc.nextDouble();
	       		int health=(int)sc.nextDouble();       		
	       		ImageView brick=makeSprite("brick"+health+".gif",x,y);
	       		brick.setFitHeight(0.05*SIZE);
	       		brick.setFitWidth(0.1*SIZE);
	       		data.brickList.add(new Brick(health,brick));
	       	}
	       	sc.close();
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
		}
		Bouncer b=new Bouncer(makeSprite(BALL_IMAGE,0.5,0.8), data.bouncerXVelocity,data.bouncerYVelocity);
    	data.bouncerList.add(b);  	
    	data.paddle=makeSprite("paddle.gif",0.5,PADDLE_ELEVATION);
    	data.paddle.setFitWidth(PADDLEWIDTH*SIZE);
    	data.paddle.setFitHeight(PADDLEHEIGHT*SIZE);
        handlePauses();
        
        data.myScene.setOnMouseMoved(e->trackMouseMovement(e.getX()));
    }

    private void step(double elapsedTime) throws FileNotFoundException {
    	for(Bouncer bouncer:data.bouncerList){
    		ImageView sprite=bouncer.getSprite();
    		sprite.setX(sprite.getX()+bouncer.xVelocity()*elapsedTime);
    		sprite.setY(sprite.getY()+bouncer.yVelocity()*elapsedTime);
    	}
    	
    	bouncerInteractions();
    	
    	ArrayList<PowerUp> tempList=new ArrayList<>();
    	for(PowerUp p:data.powerUpList){
    		ImageView sprite=p.getSprite();
    		sprite.setY(sprite.getY()+data.POWER_FALL_SPEED*elapsedTime);
    		if(!pickedUp(p)){
    			tempList.add(p);
    		}else{
    			gainPower(p.getVersion());
    			data.root.getChildren().remove(p.getSprite());
    		}
    	}
    	data.powerUpList=tempList;
    	
    	if(data.brickList.size()==0&&data.screen<=3&&data.screen>=1){
    		data.screen++;   
			setUpScreens();
			
    	}
    	updateLabels();
    }
    
    
    private void bouncerInteractions() throws FileNotFoundException{
    	boolean death=false;
    	for(Bouncer bouncer: data.bouncerList){
    		brickCollision(bouncer);
    		paddleInfluence(bouncer);
    		wallBounce(bouncer);
    		if(checkDeath(bouncer)){
    			death=true;
    		}
    	}
    	if(death==true){
    		data.lives--;
    		data.score-=3;
    		setUpScreens();
    	}
    }

	private void wallBounce(Bouncer bouncer){
		ImageView sprite=bouncer.getSprite();
		if(sprite.getX()<0||sprite.getX()+sprite.getFitWidth()>SIZE){
			bouncer.reverseX();
		}
		if(sprite.getY()<0){
			bouncer.reverseY();
		}
		
	}
	
	private boolean checkDeath(Bouncer bouncer){
		ImageView sprite=bouncer.getSprite();
		return(sprite.getY()+sprite.getFitHeight()>SIZE);		
	}

	private void brickCollision(Bouncer bouncer) {
		ArrayList<Brick> newBricks=new ArrayList<>();
		for(Brick brick: data.brickList){
			if(collisionPhysics(bouncer,brick.getSprite())){
				brick.healthDecrement();
				data.score+=1;
				if(brick.getHealth()>0){
					newBricks.add(brick);
				}
				else{
					data.root.getChildren().remove(brick.getSprite());
					randomDrop(brick);
				}
			}
			else{
				newBricks.add(brick);
			}
		}
		if(data.brickList.size()!=newBricks.size()){
			data.brickList=newBricks;
			System.gc();
		}
	}
	
	private void randomDrop(Brick brick){
		Random rn=new Random();
		int x=rn.nextInt(18);
		double brickX=brick.getSprite().getX();
		double brickY=brick.getSprite().getY();
		if(x<=5){
			dropPower(1,brickX,brickY);
		}
		else if(x<=7){
			dropPower(2,brickX,brickY);
		}
		else if(x<=10){
			dropPower(3,brickX,brickY);
		}
	}
	
	private void dropPower(int n, double x, double y){
		ImageView sprite=makeSprite(n+".gif",x/SIZE,y/SIZE);
		PowerUp p=new PowerUp(n,sprite);
		data.powerUpList.add(p);
	}
    
	private void paddleInfluence(Bouncer bouncer) {
		if(collisionPhysics(bouncer,data.paddle)){
			double dx=bouncer.getSprite().getX()+bouncer.getSprite().getFitWidth()/2-data.paddle.getX();
			double angle=Math.PI*dx/data.paddle.getFitWidth();
			double xVel=bouncer.xVelocity()-Math.cos(angle)*PADDLECONTROL;
			double yVel=bouncer.yVelocity()-Math.sin(angle)*PADDLECONTROL;
			double speedRatio=Math.sqrt((bouncer.xVelocity()*bouncer.xVelocity()+bouncer.yVelocity()*bouncer.yVelocity())/
					(xVel*xVel+yVel*yVel));
			bouncer.setVelocity(xVel*speedRatio,yVel*speedRatio);   			
		}
	}
    
    private boolean collisionPhysics(Bouncer bouncer, ImageView sprite){
    	//this kind of collision only works if things don't move by a lot per frame.
    	double bouncerWidth=bouncer.getSprite().getFitWidth();
		double bouncerHeight=bouncer.getSprite().getFitHeight();
		double bouncerX=bouncer.getSprite().getX()+bouncerWidth/2;
		double bouncerY=bouncer.getSprite().getY()+bouncerHeight/2;
		
		double spriteWidth=sprite.getFitWidth();
		double spriteHeight=sprite.getFitHeight();
		double spriteX=sprite.getX()+spriteWidth/2;
		double spriteY=sprite.getY()+spriteHeight/2;
		
		if(Math.abs(bouncerX-spriteX)<(spriteWidth+bouncerWidth)/2
				&&Math.abs(bouncerY-spriteY)<(spriteHeight+bouncerHeight)/2){
			if((bouncerHeight+spriteHeight)/2-Math.abs(bouncerY-spriteY)<
					(bouncerWidth+spriteWidth)/2-Math.abs(bouncerX-spriteX)){
				bouncer.reverseY();	
			}
			else{
				bouncer.reverseX();
			}			
			return true;
		}
		return false;
    	   	
    }
    private boolean pickedUp(PowerUp p){
    	ImageView powerSprite=p.getSprite();
    	double powerUpWidth=powerSprite.getFitWidth();
		double powerUpHeight=powerSprite.getFitHeight();
		double powerUpX=powerSprite.getX()+powerUpWidth/2;
		double powerUpY=powerSprite.getY()+powerUpHeight/2;
		
		double paddleWidth=data.paddle.getFitWidth();
		double paddleHeight=data.paddle.getFitHeight();
		double paddleX=data.paddle.getX()+paddleWidth/2;
		double paddleY=data.paddle.getY()+paddleHeight/2;
		
		return(Math.abs(powerUpX-paddleX)<(paddleWidth+powerUpWidth)/2
				&&Math.abs(powerUpY-paddleY)<(paddleHeight+powerUpHeight)/2);
    }
    
    private void gainPower(int n){
    	if(n==1){
    		for(Bouncer b:data.bouncerList){
    			b.setVelocity(b.xVelocity()*data.ACCELERATION, b.yVelocity()*data.ACCELERATION);
    			data.score+=10;
    		}
    	}
    	if(n==2){
    		for(Bouncer b:data.bouncerList){
    			b.setVelocity(b.xVelocity()*data.DECCELERATION, b.yVelocity()*data.DECCELERATION);
    			data.score+=5;
    		}
    	}
    	if(n==3){
    		ImageView ball=makeSprite(BALL_IMAGE, 0.5,0.5);
    		Bouncer b=new Bouncer(ball, data.bouncerXVelocity,data.bouncerYVelocity);
    		data.bouncerList.add(b);
    	}
    }
    
    private ImageView makeSprite(String imageName, double x, double y){
    	Image image=new Image(getClass().getClassLoader().getResourceAsStream(imageName));
    	ImageView sprite=new ImageView(image);
    	sprite.setX(x*SIZE);
    	sprite.setY(y*SIZE);
    	data.root.getChildren().add(sprite);
    	return sprite;
    }

    // What to do each time a key is pressed
    private void handleKeyInput (KeyCode code) throws FileNotFoundException {
        if (code== KeyCode.SPACE) handlePauses();
       
        if (code==KeyCode.DIGIT0){
        	data.screen=0;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT1){
        	data.screen=1;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT2){
        	data.screen=2;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT3){
        	data.screen=3;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT4){
        	data.screen=4;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT5){
        	data.screen=5;
        	setUpScreens();
        }
        if (code==KeyCode.DIGIT6){
        	data.screen=6;
        	setUpScreens();
        }
        if (code==KeyCode.L){
        	data.lives=-100;
        	data.score=-9999;
        }
    }
    
    private void handlePauses(){
    	if(playing==true){
    		data.animation.stop();
    		data.root.getChildren().add(pauseMessage);
    		data.root.applyCss();
    		data.root.layout();
    		pauseMessage.setLayoutX(SIZE/2-pauseMessage.getWidth()/2);
    		pauseMessage.setLayoutY(SIZE/2);
    		
    		playing=false;
    	}
    	else{
    		data.animation.play();
    		data.root.getChildren().remove(pauseMessage);
    		playing=true;
    	}
    }
    
    private void trackMouseMovement(double x){
    	data.paddle.setX(x);
    }

    public static void main (String[] args) {
        launch(args);
    }
}
